<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Three.js İzometrik Oyun</title>
    <style>
        body {
            font-family: sans-serif;
            text-align: center;
            background: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            justify-content: center;
        }

        h2 {
            margin-bottom: 20px;
            color: #333;
        }

        #threeJsContainer {
            width: 500px;
            height: 500px;
            border: 2px solid #aaa;
            margin: 10px;
            background-color: #fff;
            box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .options {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 30px;
            margin-bottom: 20px;
        }

        .option {
            border: 3px solid #333;
            cursor: pointer;
            background: #fff;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, border-color 0.2s;
        }

        .option:hover {
            transform: scale(1.05);
        }

        .option.correct-answer {
            border-color: green;
            box-shadow: 0 0 15px rgba(0, 128, 0, 0.7);
        }

        .option.wrong-answer {
            border-color: red;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
        }

        button {
            padding: 12px 25px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }

        #cameraIndicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="threeJsContainer">
        <div id="cameraIndicator" title="Sağ Önden Görünüm">
            <svg width="60" height="60" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <title>Sağ Önden Görünüm</title>
                <path d="M10 50 C30 20 70 20 90 50 C70 80 30 80 10 50 Z" fill="white" stroke="black" stroke-width="2" />
                <circle cx="50" cy="50" r="15" fill="blue" />
                <circle cx="50" cy="50" r="8" fill="black" />
                <circle cx="58" cy="42" r="3" fill="white" />
                <path d="M75 75 L25 25" stroke="#000000" stroke-width="5" stroke-linecap="round"
                    stroke-linejoin="round" />
                <path d="M25 25 L35 30 M25 25 L30 35" stroke="#000000" stroke-width="5" stroke-linecap="round"
                    stroke-linejoin="round" fill="#90EE90" />
            </svg>
        </div>
    </div>
    <div class="options" id="optionsContainer"></div>
    <button onclick="startGame()">Yeni Oyun</button>

    <script>
        const CUBE_SIZE_THREE = 1;
        const COLORS = {
            red: ['#ff4d4d', '#cc0000', '#990000'],
            blue: ['#4d4dff', '#0000cc', '#000099'],
            yellow: ['#ffff66', '#cccc00', '#999900'],
            green: ['#66ff66', '#00cc00', '#009900'],
            purple: ['#e6a1e6', '#a100a1', '#6b006b']
        };
        const COLOR_KEYS = Object.keys(COLORS);
        const FIXED_OPTION_BLOCK_PIXEL_SIZE = 25;


        let currentGridDimension;
        let currentMaxTowerHeight;
        let currentOptionCanvasWidth;
        let currentOptionCanvasHeight;
        let scene, camera, renderer;
        let isThreeJSInitialized = false;

        function initThreeJS() {
            if (isThreeJSInitialized) return;
            const container = document.getElementById('threeJsContainer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = 8 * CUBE_SIZE_THREE * 1.5;
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.set(20, 20, 20);
            camera.lookAt(0, 0, 0);

            const ambientLight = new THREE.AmbientLight(0x808080);
            ambientLight.name = "ambient_light";
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.name = "directional_light";
            directionalLight.position.set(20, 30, 20);
            directionalLight.castShadow = false;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            isThreeJSInitialized = true;
        }

        function updateCameraAndLights(structure) {
            if (!camera || !renderer) return;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;
            let hasBlocks = false;
            for (let x = 0; x < currentGridDimension; x++) {
                for (let y = 0; y < currentGridDimension; y++) {
                    for (let z = 0; z < currentMaxTowerHeight; z++) {
                        if (structure[x][y][z]) {
                            hasBlocks = true;
                            minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                            minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
                        }
                    }
                }
            }

            const centerX = hasBlocks ? (minX + maxX) / 2 : 0;
            const centerY = hasBlocks ? (minZ + maxZ) / 2 : 0; // 3D z (height) is 3js Y
            const centerZ = hasBlocks ? (minY + maxY) / 2 : 0; // 3D y (depth) is 3js Z

            const structureSize = hasBlocks ? Math.max(maxX - minX, maxY - minY, maxZ - minZ) + 2 : currentGridDimension;
            const camPos = structureSize * 2;
            camera.position.set(centerX + camPos, centerY + camPos, centerZ + camPos);
            camera.lookAt(centerX, centerY, centerZ);

            const light = scene.getObjectByName("directional_light");
            if (light) {
                light.position.set(centerX + camPos * 0.5, centerY + camPos, centerZ + camPos * 0.5);
            }
            renderer.render(scene, camera);
        }

        function drawStructureThreeJS(structure) {
            const objectsToRemove = [];
            scene.traverse(child => {
                if (child.isMesh) {
                    objectsToRemove.push(child);
                }
            });

            objectsToRemove.forEach(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
                scene.remove(obj);
            });

            for (let x = 0; x < currentGridDimension; x++) {
                for (let y = 0; y < currentGridDimension; y++) {
                    for (let z = 0; z < currentMaxTowerHeight; z++) {
                        const cubeColorName = structure[x][y][z];
                        if (cubeColorName) {
                            const [topHex, sideLightHex, sideDarkHex] = COLORS[cubeColorName].map(c => parseInt(c.slice(1), 16));
                            const materials = [
                                new THREE.MeshLambertMaterial({ color: sideLightHex }),
                                new THREE.MeshLambertMaterial({ color: sideDarkHex }),
                                new THREE.MeshLambertMaterial({ color: topHex }),
                                new THREE.MeshLambertMaterial({ color: sideDarkHex }),
                                new THREE.MeshLambertMaterial({ color: sideLightHex }),
                                new THREE.MeshLambertMaterial({ color: sideDarkHex })
                            ];
                            const geometry = new THREE.BoxGeometry(CUBE_SIZE_THREE, CUBE_SIZE_THREE, CUBE_SIZE_THREE);
                            const cube = new THREE.Mesh(geometry, materials);
                            cube.position.set(x, z, y);
                            cube.castShadow = true;
                            cube.receiveShadow = true;
                            scene.add(cube);
                        }
                    }
                }
            }
            updateCameraAndLights(structure);
        }

        function generateStructure() {
            let structure;
            let isStructureAcceptable = false;
            let generationAttempts = 0;

            while (!isStructureAcceptable && generationAttempts < 1000) { // Deneme limitini artırdık
                generationAttempts++;

                let candidateStructure = Array.from({ length: currentGridDimension }, () => Array.from({ length: currentGridDimension }, () => Array.from({ length: currentMaxTowerHeight }, () => null)));
                let allCubesInCandidate = [];
                const growthCandidates = [];
                const occupied = new Set();

                const startX = Math.floor(Math.random() * currentGridDimension);
                const startY = Math.floor(Math.random() * currentGridDimension);
                candidateStructure[startX][startY][0] = COLOR_KEYS[Math.floor(Math.random() * COLOR_KEYS.length)];
                occupied.add(`${startX},${startY},0`);
                allCubesInCandidate.push({ x: startX, y: startY, z: 0 });
                addNeighbors(startX, startY, 0);

                const totalBlocks = 5 + Math.floor(Math.random() * 5); // 5 ila 9 blok
                let blocksPlaced = 1;

                while (blocksPlaced < totalBlocks && growthCandidates.length > 0) {
                    const candidateIndex = Math.floor(Math.random() * growthCandidates.length);
                    const { x, y, z } = growthCandidates.splice(candidateIndex, 1)[0];
                    if (occupied.has(`${x},${y},${z}`)) continue;
                    if (z > 0 && !occupied.has(`${x},${y},${z - 1}`)) continue;

                    candidateStructure[x][y][z] = COLOR_KEYS[Math.floor(Math.random() * COLOR_KEYS.length)];
                    occupied.add(`${x},${y},${z}`);
                    allCubesInCandidate.push({ x, y, z });
                    blocksPlaced++;
                    addNeighbors(x, y, z);
                }

                function addNeighbors(x, y, z) {
                    const neighbors = [{ x: x + 1, y, z }, { x: x - 1, y, z }, { x, y: y + 1, z }, { x, y: y - 1, z }, { x, y, z: z + 1 }];
                    for (const n of neighbors) {
                        if (n.x >= 0 && n.x < currentGridDimension && n.y >= 0 && n.y < currentGridDimension && n.z >= 0 && n.z < currentMaxTowerHeight && !occupied.has(`${n.x},${n.y},${n.z}`)) {
                            growthCandidates.push(n);
                        }
                    }
                }

                if (allCubesInCandidate.length < 4) continue;

                const visibleCubes = new Set();
                const screenDepthMap = new Map();
                allCubesInCandidate.sort((a, b) => (b.x + b.y + b.z) - (a.x + a.y + a.z));

                for (const cube of allCubesInCandidate) {
                    const screenX = (cube.x - cube.y);
                    const screenY = (cube.z * 2) - (cube.x + cube.y);
                    const key = `${screenX},${screenY}`;
                    if (!screenDepthMap.has(key)) {
                        screenDepthMap.set(key, true);
                        visibleCubes.add(`${cube.x},${cube.y},${cube.z}`);
                    }
                }

                if (allCubesInCandidate.length === visibleCubes.size) {
                    isStructureAcceptable = true;
                    structure = candidateStructure;
                }
            }

            if (!isStructureAcceptable) {
                console.warn("Adil bir yapı bulunamadı! Son deneme kullanılıyor veya yeniden başlatılıyor...");
                return generateStructure(); // Adil yapı bulunamazsa, fonksiyonu tekrar çağır
            }

            return structure;
        }

        function getRightSideViewImageData(structure, ctx) {
            ctx.clearRect(0, 0, currentOptionCanvasWidth, currentOptionCanvasHeight);
            ctx.fillStyle = "#f0f0f0";
            ctx.fillRect(0, 0, currentOptionCanvasWidth, currentOptionCanvasHeight);
            const finalViewGrid = Array.from({ length: currentGridDimension }, () => Array(currentMaxTowerHeight).fill(null));
            for (let x = currentGridDimension - 1; x >= 0; x--) {
                for (let y = 0; y < currentGridDimension; y++) {
                    for (let z = 0; z < currentMaxTowerHeight; z++) {
                        if (structure[x][y][z]) {
                            const col_2d = currentGridDimension - 1 - y;
                            const row_2d = currentMaxTowerHeight - 1 - z;
                            if (finalViewGrid[col_2d][row_2d] === null) {
                                finalViewGrid[col_2d][row_2d] = structure[x][y][z];
                            }
                        }
                    }
                }
            }
            for (let col_2d = 0; col_2d < currentGridDimension; col_2d++) {
                for (let row_2d = 0; row_2d < currentMaxTowerHeight; row_2d++) {
                    const colorName = finalViewGrid[col_2d][row_2d];
                    if (colorName !== null) {
                        const [, sideLightHex] = COLORS[colorName];
                        const drawX = col_2d * FIXED_OPTION_BLOCK_PIXEL_SIZE;
                        const drawY = row_2d * FIXED_OPTION_BLOCK_PIXEL_SIZE;
                        const margin = 1;
                        ctx.fillStyle = sideLightHex;
                        ctx.fillRect(drawX + margin, drawY + margin, FIXED_OPTION_BLOCK_PIXEL_SIZE - 2 * margin, FIXED_OPTION_BLOCK_PIXEL_SIZE - 2 * margin);
                        ctx.strokeStyle = "#333";
                        ctx.lineWidth = 1;
                        ctx.strokeRect(drawX + margin, drawY + margin, FIXED_OPTION_BLOCK_PIXEL_SIZE - 2 * margin, FIXED_OPTION_BLOCK_PIXEL_SIZE - 2 * margin);
                    }
                }
            }
            return ctx.getImageData(0, 0, currentOptionCanvasWidth, currentOptionCanvasHeight);
        }

        function drawView(imageData, container, isCorrect = false) {
            const optionCanvas = document.createElement("canvas");
            optionCanvas.width = imageData.width;
            optionCanvas.height = imageData.height;
            optionCanvas.className = 'option';
            const optCtx = optionCanvas.getContext('2d', { willReadFrequently: true });
            optCtx.putImageData(imageData, 0, 0);
            optionCanvas.onclick = () => {
                document.querySelectorAll('.option').forEach(opt => {
                    opt.classList.remove('correct-answer', 'wrong-answer');
                    opt.onclick = null;
                });
                if (isCorrect) {
                    optionCanvas.classList.add('correct-answer');
                    setTimeout(() => { alert("✅ Doğru cevap!"); }, 100);
                } else {
                    optionCanvas.classList.add('wrong-answer');
                    const correctOption = document.querySelector('.option.is-correct');
                    if (correctOption) {
                        correctOption.classList.add('correct-answer');
                    }
                    setTimeout(() => { alert("❌ Yanlış cevap!"); }, 100);
                }
            };
            if (isCorrect) {
                optionCanvas.classList.add('is-correct');
            }
            container.appendChild(optionCanvas);
        }

        function generateWrongView(correctImageData) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = correctImageData.width;
            tempCanvas.height = correctImageData.height;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCtx.putImageData(correctImageData, 0, 0);
            const baseGrid = Array.from({ length: currentGridDimension }, () => Array(currentMaxTowerHeight).fill(null));
            const colorTolerance = 20;
            for (let c = 0; c < currentGridDimension; c++) {
                for (let r = 0; r < currentMaxTowerHeight; r++) {
                    const sampleX = Math.floor(c * FIXED_OPTION_BLOCK_PIXEL_SIZE + FIXED_OPTION_BLOCK_PIXEL_SIZE / 2);
                    const sampleY = Math.floor(r * FIXED_OPTION_BLOCK_PIXEL_SIZE + FIXED_OPTION_BLOCK_PIXEL_SIZE / 2);
                    const pixelData = tempCtx.getImageData(sampleX, sampleY, 1, 1).data;
                    if (pixelData[3] < 255) continue;
                    for (const key of COLOR_KEYS) {
                        const [, sideLightHex] = COLORS[key];
                        const colorR = parseInt(sideLightHex.slice(1, 3), 16);
                        const colorG = parseInt(sideLightHex.slice(3, 5), 16);
                        const colorB = parseInt(sideLightHex.slice(5, 7), 16);
                        if (Math.abs(pixelData[0] - colorR) < colorTolerance && Math.abs(pixelData[1] - colorG) < colorTolerance && Math.abs(pixelData[2] - colorB) < colorTolerance) {
                            baseGrid[c][r] = key;
                            break;
                        }
                    }
                }
            }
            const wrongGrid = JSON.parse(JSON.stringify(baseGrid));
            let changesMade = 0;
            let attempts = 0;
            while (changesMade < 1 && attempts < 50) {
                attempts++;
                const allBlocks = [];
                const emptyCells = [];
                for (let c = 0; c < currentGridDimension; c++) {
                    for (let r = 0; r < currentMaxTowerHeight; r++) {
                        if (wrongGrid[c][r]) allBlocks.push({ c, r, color: wrongGrid[c][r] });
                        else emptyCells.push({ c, r });
                    }
                }
                if (allBlocks.length === 0 && emptyCells.length === 0) break;
                const mutationType = Math.random();
                if (mutationType < 0.4 && allBlocks.length > 0) {
                    const block = allBlocks[Math.floor(Math.random() * allBlocks.length)];
                    const availableColors = COLOR_KEYS.filter(k => k !== block.color);
                    if (availableColors.length > 0) {
                        wrongGrid[block.c][block.r] = availableColors[Math.floor(Math.random() * availableColors.length)];
                        changesMade++;
                    }
                }
                else if (mutationType < 0.7 && allBlocks.length > 0) {
                    const block = allBlocks[Math.floor(Math.random() * allBlocks.length)];
                    for (let row_to_clear = block.r; row_to_clear >= 0; row_to_clear--) {
                        if (wrongGrid[block.c][row_to_clear]) {
                            wrongGrid[block.c][row_to_clear] = null;
                            changesMade = 1;
                        }
                    }
                }
                else {
                    const validAddSpots = emptyCells.filter(cell => cell.r === currentMaxTowerHeight - 1 || (wrongGrid[cell.c][cell.r + 1] !== null));
                    if (validAddSpots.length > 0) {
                        const spot = validAddSpots[Math.floor(Math.random() * validAddSpots.length)];
                        wrongGrid[spot.c][spot.r] = COLOR_KEYS[Math.floor(Math.random() * COLOR_KEYS.length)];
                        changesMade++;
                    }
                }
            }
            const wrongOptionCanvas = document.createElement('canvas');
            wrongOptionCanvas.width = correctImageData.width;
            wrongOptionCanvas.height = correctImageData.height;
            const wrongOptCtx = wrongOptionCanvas.getContext('2d', { willReadFrequently: true });
            wrongOptCtx.fillStyle = "#f0f0f0";
            wrongOptCtx.fillRect(0, 0, correctImageData.width, correctImageData.height);
            for (let c = 0; c < currentGridDimension; c++) {
                for (let r = 0; r < currentMaxTowerHeight; r++) {
                    const colorName = wrongGrid[c][r];
                    if (colorName !== null) {
                        const [, sideLightHex] = COLORS[colorName];
                        wrongOptCtx.fillStyle = sideLightHex;
                        wrongOptCtx.fillRect(c * FIXED_OPTION_BLOCK_PIXEL_SIZE + 1, r * FIXED_OPTION_BLOCK_PIXEL_SIZE + 1, FIXED_OPTION_BLOCK_PIXEL_SIZE - 2, FIXED_OPTION_BLOCK_PIXEL_SIZE - 2);
                        wrongOptCtx.strokeStyle = "#333";
                        wrongOptCtx.strokeRect(c * FIXED_OPTION_BLOCK_PIXEL_SIZE + 1, r * FIXED_OPTION_BLOCK_PIXEL_SIZE + 1, FIXED_OPTION_BLOCK_PIXEL_SIZE - 2, FIXED_OPTION_BLOCK_PIXEL_SIZE - 2);
                    }
                }
            }
            return wrongOptCtx.getImageData(0, 0, correctImageData.width, correctImageData.height);
        }

        function startGame() {
            currentGridDimension = 4;
            currentMaxTowerHeight = 4;
            currentOptionCanvasWidth = currentGridDimension * FIXED_OPTION_BLOCK_PIXEL_SIZE;
            currentOptionCanvasHeight = currentMaxTowerHeight * FIXED_OPTION_BLOCK_PIXEL_SIZE;

            initThreeJS();

            const structure = generateStructure();
            if (!structure) {
                alert("Adil bir yapı üretilemedi, lütfen sayfayı yenileyin. Bu nadiren olur.");
                return;
            }

            drawStructureThreeJS(structure);

            const dummyCanvas = document.createElement('canvas');
            dummyCanvas.width = currentOptionCanvasWidth;
            dummyCanvas.height = currentOptionCanvasHeight;
            const dummyCtx = dummyCanvas.getContext('2d', { willReadFrequently: true });

            const correctViewImageData = getRightSideViewImageData(structure, dummyCtx);
            const wrongViewsImageData = [];
            let attempts = 0;
            while (wrongViewsImageData.length < 3 && attempts < 200) {
                const wrong = generateWrongView(correctViewImageData);
                if (wrong) {
                    const isDuplicate = Array.from(wrong.data).join(',') === Array.from(correctViewImageData.data).join(',') || wrongViewsImageData.some(imgData => Array.from(imgData.data).join(',') === Array.from(wrong.data).join(','));
                    if (!isDuplicate) {
                        wrongViewsImageData.push(wrong);
                    }
                }
                attempts++;
            }

            const allOptions = [{ view: correctViewImageData, correct: true }, ...wrongViewsImageData.map(v => ({ view: v, correct: false }))].sort(() => Math.random() - 0.5);
            const optionsContainer = document.getElementById("optionsContainer");
            optionsContainer.innerHTML = '';
            allOptions.forEach(opt => drawView(opt.view, optionsContainer, opt.correct));
        }

        startGame();
    </script>
</body>

</html>