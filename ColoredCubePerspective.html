<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colored Cube Perspective</title>
    <style>
        /* İkonlar ve fontlar için linkler */
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap');

        :root {
            --bg-color: #ffffff;
            --main-card-bg: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0);
            --border-radius: 20px;
            --correct-color: #2ecc71;
            --incorrect-color: #e74c3c;

            /* Prizma Boyutları */
            --tile-width: 80px;
            --tile-height: 40px;
            --tile-z-unit: 25px;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }

        .game-container {
            width: 100%;
            max-width: 800px;
            text-align: center;
        }

        .puzzle-area {
            background-color: var(--main-card-bg);
            height: 450px;
            margin-bottom: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        #puzzle-container {
            position: relative;
            width: 100%;
            flex-grow: 1;
            min-height: 0;
        }

        .view-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: #555;
            font-size: 1.2em;
            pointer-events: none;
            padding: 15px 0 10px 0;
            flex-shrink: 0;
        }

        .prism-face {
            position: absolute;
            box-sizing: border-box;
        }

        .options-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .option-box {
            background-color: var(--main-card-bg);
            border-radius: 0;
            padding: 10px;
            box-shadow: 0 2px 8px var(--shadow-color);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: grid;
            gap: 0;
            border: 4px solid transparent;
            margin: 5px;
        }

        .option-cell {
            transition: transform 0.2s ease-in-out, z-index 0s 0.1s;
            border-radius: 0;
        }

        .option-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px var(--shadow-color);
        }

        .option-box.disabled {
            pointer-events: none;
            opacity: 0.7;
        }

        .option-box.correct {
            border-color: var(--correct-color);
        }

        .option-box.incorrect {
            border-color: var(--incorrect-color);
        }
    </style>
</head>

<body>
    <span id="correctIndex" style="display:none;"></span>

    <div class="game-container">
        <div id="question-area-main" class="puzzle-area">
            <div id="puzzle-container">
            </div>
        </div>
        <div id="options-container" class="options-area"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const COLORS = ['#e74c3c', '#8e44ad', '#3498db', '#1abc9c', '#f1c40f', '#e67e22'];

            const questionAreaMain = document.getElementById('question-area-main');
            const optionsContainer = document.getElementById('options-container');

            const TILE_W = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-width'));
            const TILE_H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-height'));
            const TILE_Z = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-z-unit'));

            let gameState = { isLocked: false };

            function darkenColor(hex, percent) {
                if (!hex || typeof hex !== 'string') return '#000000';
                let r = parseInt(hex.substring(1, 3), 16);
                let g = parseInt(hex.substring(3, 5), 16);
                let b = parseInt(hex.substring(5, 7), 16);
                const factor = (100 - percent) / 100;
                r = Math.floor(r * factor);
                g = Math.floor(g * factor);
                b = Math.floor(b * factor);
                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0')}`;
            }

            function generatePuzzleData() {
                const size = Math.random() < 0.5 ? 3 : 4;
                const gridRows = size;
                const gridCols = size;
                gameState.gridCols = gridCols;
                gameState.gridRows = gridRows;

                let structure;
                let blocks;

                do {
                    structure = Array(gridRows).fill(null).map(() => Array(gridCols).fill(null));
                    let blockCount = 0;
                    const targetBlockCount = random.int(size + 1, size * size - Math.floor(size / 2));

                    const startR = random.int(0, gridRows - 1);
                    const startC = random.int(0, gridCols - 1);
                    structure[startR][startC] = { r: startR, c: startC, height: 0, color: 'placeholder' };
                    blockCount++;

                    const getNeighbors = (r, c) => {
                        const neighbors = [];
                        if (r > 0) neighbors.push({ r: r - 1, c: c });
                        if (r < gridRows - 1) neighbors.push({ r: r + 1, c: c });
                        if (c > 0) neighbors.push({ r: r, c: c - 1 });
                        if (c < gridCols - 1) neighbors.push({ r: r, c: c + 1 });
                        return neighbors;
                    };

                    let frontier = [];
                    getNeighbors(startR, startC).forEach(n => {
                        if (!structure[n.r][n.c]) { frontier.push(n); }
                    });

                    while (blockCount < targetBlockCount && frontier.length > 0) {
                        random.shuffle(frontier);
                        const nextCell = frontier.pop();
                        if (structure[nextCell.r][nextCell.c]) continue;
                        structure[nextCell.r][nextCell.c] = { r: nextCell.r, c: nextCell.c, height: 0, color: 'placeholder' };
                        blockCount++;
                        getNeighbors(nextCell.r, nextCell.c).forEach(n => {
                            if (!structure[n.r][n.c] && !frontier.some(f => f.r === n.r && f.c === n.c)) {
                                frontier.push(n);
                            }
                        });
                    }
                    blocks = structure.flat().filter(Boolean);
                } while (blocks.length < size + 1);

                for (let r = gridRows - 1; r >= 0; r--) {
                    for (let c = gridCols - 1; c >= 0; c--) {
                        if (structure[r][c]) {
                            const frontBlockHeight = (r < gridRows - 1 && structure[r + 1][c]) ? structure[r + 1][c].height : 0;
                            const sideBlockHeight = (c < gridCols - 1 && structure[r][c + 1]) ? structure[r][c + 1].height : 0;
                            const tallestOccludingBlock = Math.max(frontBlockHeight, sideBlockHeight);
                            structure[r][c].height = tallestOccludingBlock + random.int(1, 2);
                        }
                    }
                }

                const availableColors = [...COLORS];
                random.shuffle(availableColors);
                let colorIndex = 0;
                blocks.forEach(block => {
                    block.color = availableColors[colorIndex % availableColors.length];
                    colorIndex++;
                });

                const correctOptionData = structure.map(row =>
                    row.map(cell => (cell ? { color: cell.color, height: cell.height } : null))
                );

                const originalColors = blocks.map(cell => cell.color);

                const usedColorPermutations = [JSON.stringify(originalColors)];
                const options = [correctOptionData];

                while (options.length < 4) {
                    const shuffledColors = [...originalColors];
                    random.shuffle(shuffledColors);
                    const newPermutationString = JSON.stringify(shuffledColors);

                    if (!usedColorPermutations.includes(newPermutationString)) {
                        usedColorPermutations.push(newPermutationString);

                        const newOption = [];
                        let localColorIndex = 0;
                        for (let r = 0; r < gridRows; r++) {
                            const newRow = [];
                            for (let c = 0; c < gridCols; c++) {
                                if (structure[r][c]) {
                                    newRow.push({ color: shuffledColors[localColorIndex], height: structure[r][c].height });
                                    localColorIndex++;
                                } else {
                                    newRow.push(null);
                                }
                            }
                            newOption.push(newRow);
                        }
                        options.push(newOption);
                    }
                }

                random.shuffle(options);
                gameState.structure = structure;
                gameState.options = options;
                gameState.correctIndex = options.findIndex(opt => JSON.stringify(opt) === JSON.stringify(correctOptionData));
            }


            function renderPuzzle() {
                questionAreaMain.innerHTML = '<div id="puzzle-container"></div>';
                const newPuzzleContainer = document.getElementById('puzzle-container');
                optionsContainer.innerHTML = '';


                const blocksToRender = gameState.structure.flat().filter(Boolean);
                if (blocksToRender.length === 0) return;
                blocksToRender.sort((a, b) => (a.r + a.c) - (b.r + b.c));

                // --- YENİ: Otomatik sığdırma (scaling) mantığı ---
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

                // 1. Orijinal boyutları hesapla
                blocksToRender.forEach(({ height, r, c }) => {
                    const totalBlockHeight = height * TILE_Z;
                    const topPointX = (c - r) * (TILE_W / 2);
                    const topPointY = (c + r) * (TILE_H / 2) - totalBlockHeight;

                    minX = Math.min(minX, topPointX - TILE_W / 2);
                    maxX = Math.max(maxX, topPointX + TILE_W / 2);
                    minY = Math.min(minY, topPointY);
                    maxY = Math.max(maxY, topPointY + TILE_H + totalBlockHeight);
                });

                const shapeWidth = maxX - minX;
                const shapeHeight = maxY - minY;

                // 2. Sığdırmak için ölçek faktörünü hesapla
                const padding = 40; // Kenarlarda boşluk bırak
                const availableWidth = newPuzzleContainer.offsetWidth - padding;
                const availableHeight = newPuzzleContainer.offsetHeight - padding;
                const scale = Math.min(1, availableWidth / shapeWidth, availableHeight / shapeHeight);

                // 3. Ölçeklenmiş boyutlarla merkezleme ofsetini hesapla
                const scaledShapeWidth = shapeWidth * scale;
                const scaledShapeHeight = shapeHeight * scale;
                const offsetX = (newPuzzleContainer.offsetWidth - scaledShapeWidth) / 2 - (minX * scale);
                const offsetY = (newPuzzleContainer.offsetHeight - scaledShapeHeight) / 2 - (minY * scale);

                // 4. Ölçeklenmiş değerlerle prizmaları oluştur
                blocksToRender.forEach(({ height, r, c, color }) => {
                    const totalBlockHeight = height * TILE_Z;
                    const topPointX = (c - r) * (TILE_W / 2);
                    const topPointY = (c + r) * (TILE_H / 2) - totalBlockHeight;

                    const finalX = (topPointX * scale) + offsetX;
                    const finalY = (topPointY * scale) + offsetY;

                    const sTILE_W = TILE_W * scale;
                    const sTILE_H = TILE_H * scale;
                    const sTotalBlockHeight = totalBlockHeight * scale;

                    const leftFace = document.createElement('div');
                    leftFace.className = 'prism-face';
                    leftFace.style.cssText = `width:${sTILE_W / 2 + 1}px; height:${sTotalBlockHeight}px; left:${finalX - sTILE_W / 2}px; top:${finalY + sTILE_H / 2}px; background:${darkenColor(color, 25)}; clip-path:polygon(0% 0%, 100% ${sTILE_H / 2}px, 100% 100%, 0% calc(100% - ${sTILE_H / 2}px));`;

                    const rightFace = document.createElement('div');
                    rightFace.className = 'prism-face';
                    rightFace.style.cssText = `width:${sTILE_W / 2}px; height:${sTotalBlockHeight}px; left:${finalX}px; top:${finalY + sTILE_H / 2}px; background:${darkenColor(color, 15)}; clip-path:polygon(0% ${sTILE_H / 2}px, 100% 0, 100% calc(100% - ${sTILE_H / 2}px), 0% 100%);`;

                    const topFace = document.createElement('div');
                    topFace.className = 'prism-face';
                    topFace.style.cssText = `width:${sTILE_W}px; height:${sTILE_H}px; left:${finalX - sTILE_W / 2}px; top:${finalY + 1}px; background:${color}; clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);`;

                    newPuzzleContainer.appendChild(leftFace);
                    newPuzzleContainer.appendChild(rightFace);
                    newPuzzleContainer.appendChild(topFace);
                });

                // --- GÖSTERGE DEĞİŞTİRİLDİ ---
                const indicator = document.createElement('div');
                indicator.className = 'view-indicator';
                indicator.innerHTML = `
                    <svg viewBox="0 0 100 85" xmlns="http://www.w3.org/2000/svg" width="50"> 
                        <path d="M50 15C25 15 5 35 5 35S25 55 50 55s45-20 45-20S75 15 50 15z" fill="none" stroke="#333" stroke-width="5" /> 
                        <circle cx="50" cy="35" r="15" fill="#333" /> 
                        <path d="M35 55 L35 80 L30 75 M35 80 L40 75" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" /> 
                        <path d="M50 55 L50 80 L45 75 M50 80 L55 75" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" /> 
                        <path d="M65 55 L65 80 L60 75 M65 80 L70 75" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" /> 
                    </svg>
                `;
                questionAreaMain.insertBefore(indicator, newPuzzleContainer);


                // SEÇENEKLER
                gameState.options.forEach((optionData, index) => {
                    const optionBox = document.createElement('div');
                    optionBox.className = 'option-box';
                    optionBox.dataset.index = index;
                    optionBox.style.gridTemplateColumns = `repeat(${gameState.gridCols}, 48px)`;
                    optionBox.style.gridTemplateRows = `repeat(${gameState.gridRows}, 48px)`;

                    optionData.flat().forEach(cellInfo => {
                        const cell = document.createElement('div');
                        cell.className = 'option-cell';
                        cell.style.width = '48px';
                        cell.style.height = '48px';

                        if (cellInfo) {
                            cell.style.backgroundColor = cellInfo.color;
                        } else {
                            cell.style.backgroundColor = 'transparent';
                        }
                        optionBox.appendChild(cell);
                    });

                    optionBox.addEventListener('click', handleOptionClick);
                    optionsContainer.appendChild(optionBox);
                });

                document.getElementById('correctIndex').textContent = gameState.correctIndex;
            }

            function handleOptionClick(event) {
                if (gameState.isLocked) return;
                gameState.isLocked = true;
                const clickedBox = event.currentTarget;
                const clickedIndex = parseInt(clickedBox.dataset.index);

                document.querySelectorAll('.option-box').forEach(box => box.classList.add('disabled'));

                if (clickedIndex === gameState.correctIndex) {
                    clickedBox.classList.add('correct');
                } else {
                    clickedBox.classList.add('incorrect');
                    const correctBox = document.querySelector(`.option-box[data-index='${gameState.correctIndex}']`);
                    if (correctBox) { correctBox.classList.add('correct'); }
                }
                setTimeout(startGame, 2500);
            }

            const random = {
                int: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
                shuffle: (arr) => {
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                }
            };

            function startGame() {
                gameState.isLocked = false;
                generatePuzzleData();
                renderPuzzle();
            }

            window.addEventListener('resize', renderPuzzle);
            startGame();
        });
    </script>

</body>

</html>