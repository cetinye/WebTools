<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Mantık Oyunu (Tamamen Stabil)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f2f5;
            color: #333;
            padding: 20px 0;
        }

        h1 {
            color: #1c1e21;
            text-align: center;
        }

        #game-container {
            padding: 20px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #rule-description {
            background-color: #e7f3ff;
            border: 1px solid #b3d7ff;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #004085;
            text-align: center;
            max-width: 400px;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            border: 2px solid #ddd;
            padding: 10px;
            border-radius: 8px;
        }

        .cell {
            width: 90px;
            height: 90px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 45px;
            font-weight: bold;
            color: #555;
        }

        .cell svg {
            width: 100%;
            height: 100%;
        }

        #options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            max-width: 420px;
            min-height: 100px;
        }

        .option {
            width: 90px;
            height: 90px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s ease, border-color 0.2s ease;
            background-color: #fff;
            padding: 5px;
            box-sizing: border-box;
        }

        .option:hover {
            transform: translateY(-5px);
            border-color: #007bff;
        }

        #feedback {
            height: 30px;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
        }

        #feedback.correct {
            color: #28a745;
        }

        #feedback.incorrect {
            color: #dc3545;
        }

        #new-game-btn {
            padding: 12px 24px;
            font-size: 1.1em;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 10px;
        }

        #new-game-btn:hover {
            background-color: #0056b3;
        }
    </style>
</head>

<body>

    <h1>Ultimate Mantık Oyunu</h1>
    <div id="game-container">
        <div id="rule-description">Oyunda birçok farklı kural var! Kuralı çözmek için ilk iki satırı dikkatle inceleyin.
        </div>
        <div id="grid"></div>
        <p>Soru işaretli yere hangisi gelmeli?</p>
        <div id="options"></div>
        <div id="feedback"></div>
        <button id="new-game-btn">Yeni Oyun</button>
    </div>

    <script>
        const gridContainer = document.getElementById('grid');
        const optionsContainer = document.getElementById('options');
        const feedbackEl = document.getElementById('feedback');
        const newGameBtn = document.getElementById('new-game-btn');

        const COLORS = ['#d92525', '#007bff', '#1f9e4a', '#ffc107', '#6f42c1', '#fd7e14'];
        const SVG_NS = "http://www.w3.org/2000/svg";

        let correctAnswerData = {};
        let currentRule;
        let usedColors = [];

        function createSVGElement(tag, attributes) {
            const el = document.createElementNS(SVG_NS, tag);
            for (const key in attributes) {
                el.setAttribute(key, attributes[key]);
            }
            return el;
        }

        function createSVG(elements, defs = null) {
            const svg = document.createElementNS(SVG_NS, "svg");
            svg.setAttribute("viewBox", "0 0 100 100");
            if (defs) svg.appendChild(defs);
            elements.forEach(el => {
                if (el) svg.appendChild(el)
            });
            return svg;
        }

        function createGroup(elements, transforms = {}) {
            const g = createSVGElement('g', transforms);
            elements.forEach(el => g.appendChild(el));
            return g;
        }

        function createPolygon(sides, color, style) {
            const points = [];
            const radius = 40;
            const center = 50;
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI - Math.PI / 2 + (sides % 2 === 0 ? Math.PI / sides : 0);
                points.push(`${center + radius * Math.cos(angle)},${center + radius * Math.sin(angle)}`);
            }
            const polygon = createSVGElement("polygon", {
                points: points.join(" ")
            });
            applyStyle(polygon, color, style);
            return createSVG([polygon]);
        }

        function createStar(color, style) {
            const starPath = createSVGElement('path', {
                d: "M50,5 L61.8,38.2 L98.5,42.2 L72.2,65.3 L79.6,99 L50,81.3 L20.4,99 L27.8,65.3 L1.5,42.2 L38.2,38.2 Z"
            });
            return createSVG([applyStyle(starPath, color, style)]);
        }

        function applyStyle(element, color, style) {
            element.setAttribute('fill', 'none');
            element.setAttribute('stroke', 'none');
            if (style.fill) {
                element.setAttribute('fill', style.fill === true ? color : style.fill);
            }
            if (style.stroke) {
                element.setAttribute('stroke', style.stroke === true ? color : style.stroke);
                element.setAttribute('stroke-width', style.strokeWidth || '8');
            }
            if (style.opacity) {
                element.setAttribute('opacity', style.opacity);
            }
            return element;
        }

        function generateFallbackDistractor(color) {
            const randomSides = Math.floor(Math.random() * 4) + 3;
            const randomStyle = Math.random() > 0.5 ? {
                fill: true
            } : {
                stroke: true
            };
            const randomShape = Math.random() > 0.2 ? createPolygon(randomSides, color, randomStyle) : createStar(color, randomStyle);
            return {
                svg: randomShape
            };
        }

        const RULES = [{
            name: "Rotation 90 Clockwise",
            generateRow: (color) => {
                const arrow = createSVGElement('path', {
                    d: "M50 15 L70 40 L55 40 L55 85 L45 85 L45 40 L30 40 Z"
                });
                const create = (angle) => createSVG([createGroup([applyStyle(arrow.cloneNode(true), color, {
                    fill: true
                })], {
                    transform: `rotate(${angle} 50 50)`
                })]);
                const cells = [create(0), create(90), create(180)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(270)
                    }, {
                        svg: create(0)
                    }, {
                        svg: createPolygon(3, color, {
                            fill: true
                        })
                    }]
                };
            }
        }, {
            name: "Add Element",
            generateRow: (color) => {
                const create = (dotCount) => {
                    const rect = createSVGElement('rect', {
                        x: 15,
                        y: 15,
                        width: 70,
                        height: 70
                    });
                    applyStyle(rect, color, {
                        stroke: true,
                        fill: 'none'
                    });
                    const dots = [
                        createSVGElement('circle', {
                            cx: 35,
                            cy: 35,
                            r: 5,
                            fill: color
                        }),
                        createSVGElement('circle', {
                            cx: 65,
                            cy: 65,
                            r: 5,
                            fill: color
                        }),
                        createSVGElement('circle', {
                            cx: 50,
                            cy: 50,
                            r: 5,
                            fill: color
                        })
                    ];
                    return createSVG([rect, ...dots.slice(0, dotCount)]);
                };
                const cells = [create(0), create(1), create(2)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(3)
                    }, {
                        svg: create(1)
                    }, {
                        svg: create(0)
                    }]
                };
            }
        }, {
            name: "Merge Parts",
            generateRow: (color) => {
                const parts = {
                    left: createSVG([createSVGElement('path', {
                        d: "M50,10 A40,40 0 0,0 50,90 Z",
                        fill: color
                    })]),
                    right: createSVG([createSVGElement('path', {
                        d: "M50,10 A40,40 0 0,1 50,90 Z",
                        fill: color
                    })]),
                    full: createSVG([createSVGElement('circle', {
                        cx: 50,
                        cy: 50,
                        r: 40,
                        fill: color
                    })])
                };
                const cells = [parts.left, parts.right, parts.full];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: parts.left
                    }, {
                        svg: parts.right
                    }, {
                        svg: createPolygon(4, color, {
                            fill: true
                        })
                    }]
                };
            }
        }, {
            name: "Side Count Progression",
            generateRow: (color) => {
                const startSides = Math.floor(Math.random() * 2) + 3;
                const cells = [createPolygon(startSides, color, {
                    fill: true
                }), createPolygon(startSides + 1, color, {
                    fill: true
                }), createPolygon(startSides + 2, color, {
                    fill: true
                })];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: createPolygon(startSides + 3, color, {
                            fill: true
                        })
                    }, {
                        svg: createPolygon(startSides, color, {
                            fill: true
                        })
                    }, {
                        svg: createPolygon(startSides + 2, color, {
                            stroke: true
                        })
                    }]
                };
            }
        }, {
            name: "Fill/Stroke Toggle",
            generateRow: (color) => {
                const cells = [createPolygon(5, color, {
                    fill: true
                }), createPolygon(5, color, {
                    stroke: true
                }), createPolygon(5, color, {
                    fill: true
                })];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: createPolygon(5, color, {
                            stroke: true
                        })
                    }, {
                        svg: createPolygon(6, color, {
                            fill: true
                        })
                    }, {
                        svg: createStar(color, {
                            fill: true
                        })
                    }]
                };
            }
        }, {
            name: "Logical XOR",
            generateRow: (color) => {
                const clipId = `clip-xor-${Math.random()}`;
                const defs = createSVGElement('defs', {});
                defs.innerHTML = `<clipPath id="${clipId}" clip-rule="evenodd"><rect x="0" y="0" width="100" height="100" /><rect x="25" y="25" width="50" height="50" /></clipPath>`;
                const outer = createSVGElement('circle', {
                    cx: 50,
                    cy: 50,
                    r: 45,
                    fill: color
                });
                const inner = createSVGElement('rect', {
                    x: 25,
                    y: 25,
                    width: 50,
                    height: 50,
                    fill: color
                });
                const xorShape = outer.cloneNode(true);
                xorShape.setAttribute("clip-path", `url(#${clipId})`);
                const cells = [createSVG([outer.cloneNode(true)]), createSVG([inner.cloneNode(true)]), createSVG([xorShape], defs)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: createSVG([outer.cloneNode(true), inner.cloneNode(true)])
                    }, {
                        svg: createSVG([outer.cloneNode(true)])
                    }, {
                        svg: createSVG([inner.cloneNode(true)])
                    }]
                };
            }
        }, {
            name: "Grow",
            generateRow: (color) => {
                const create = (scale) => {
                    const star = createStar(color, {
                        fill: true
                    }).firstChild;
                    const g = createGroup([star], {
                        transform: `translate(50, 50) scale(${scale}) translate(-50, -50)`
                    });
                    return createSVG([g]);
                };
                const cells = [create(0.6), create(0.8), create(1.0)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(0.4)
                    }, {
                        svg: create(1.2)
                    }, {
                        svg: createPolygon(5, color, {
                            stroke: true
                        })
                    }]
                };
            }
        }, {
            name: "Color Cycle",
            generateRow: (color) => {
                const colorIndex = COLORS.indexOf(color);
                const nextColor = COLORS[(colorIndex + 1) % COLORS.length];
                const nextNextColor = COLORS[(colorIndex + 2) % COLORS.length];
                const cells = [
                    createPolygon(5, color, {
                        fill: true
                    }),
                    createPolygon(5, nextColor, {
                        fill: true
                    }),
                    createPolygon(5, nextNextColor, {
                        fill: true
                    })
                ];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: createPolygon(5, COLORS[(colorIndex + 3) % COLORS.length], {
                            fill: true
                        })
                    }, {
                        svg: createPolygon(4, nextNextColor, {
                            fill: true
                        })
                    }, {
                        svg: createPolygon(5, color, {
                            fill: true
                        })
                    }]
                };
            }
        }, {
            name: "Stroke Width Increase",
            generateRow: (color) => {
                const create = (width) => createPolygon(4, color, {
                    stroke: true,
                    strokeWidth: width
                });
                const cells = [create(4), create(10), create(16)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(22)
                    }, {
                        svg: create(4)
                    }, {
                        svg: createPolygon(4, color, {
                            fill: true
                        })
                    }]
                };
            }
        }, {
            name: "Logical Intersection",
            generateRow: (color) => {
                const clipId = `clip-int-${Math.random()}`;
                const defs = createSVGElement('defs', {});
                const clipPath = createSVGElement('clipPath', {
                    id: clipId
                });
                clipPath.appendChild(createSVGElement('rect', {
                    x: 10,
                    y: 10,
                    width: 80,
                    height: 80
                }));
                defs.appendChild(clipPath);

                const shape1 = createSVGElement('circle', {
                    cx: 50,
                    cy: 50,
                    r: 40,
                    fill: color
                });
                const shape2 = createSVGElement('rect', {
                    x: 10,
                    y: 10,
                    width: 80,
                    height: 80,
                    fill: color
                });
                const intersection = createSVGElement('circle', {
                    cx: 50,
                    cy: 50,
                    r: 40,
                    fill: color,
                    "clip-path": `url(#${clipId})`
                });

                const cells = [createSVG([shape1.cloneNode(true)]), createSVG([shape2.cloneNode(true)]), createSVG([intersection], defs)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: createSVG([shape1.cloneNode(true), shape2.cloneNode(true)])
                    }, {
                        svg: createSVG([shape1.cloneNode(true)])
                    }, {
                        svg: createSVG([shape2.cloneNode(true)])
                    }]
                };
            }
        }, {
            name: "Rotation 90 Counter-Clockwise",
            generateRow: (color) => {
                const arrow = createSVGElement('path', {
                    d: "M50 15 L70 40 L55 40 L55 85 L45 85 L45 40 L30 40 Z"
                });
                const create = (angle) => createSVG([createGroup([applyStyle(arrow.cloneNode(true), color, {
                    fill: true
                })], {
                    transform: `rotate(${angle} 50 50)`
                })]);
                const cells = [create(0), create(-90), create(-180)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(-270)
                    }, {
                        svg: create(90)
                    }, {
                        svg: create(0)
                    }]
                };
            }
        }, {
            name: "Horizontal Flip",
            generateRow: (color) => {
                const shape = createSVGElement('path', {
                    d: "M30 20 V 80 H 50 A 15 15 0 0 0 50 50 H 30"
                });
                const create = (scaleX = 1) => createSVG([createGroup([applyStyle(shape.cloneNode(true), color, {
                    fill: true
                })], {
                    transform: `scale(${scaleX}, 1) translate(${scaleX === -1 ? -100 : 0}, 0)`
                })]);
                const cells = [create(1), create(-1), create(1)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(-1)
                    }, {
                        svg: createStar(color, {
                            fill: true
                        })
                    }, {
                        svg: createPolygon(4, color, {
                            stroke: true
                        })
                    }]
                };
            }
        }, {
            name: "Vertical Flip",
            generateRow: (color) => {
                const shape = createSVGElement('path', {
                    d: "M20 30 H 80 V 50 A 15 15 0 0 1 50 50 H 20"
                });
                const create = (scaleY = 1) => createSVG([createGroup([applyStyle(shape.cloneNode(true), color, {
                    fill: true
                })], {
                    transform: `scale(1, ${scaleY}) translate(0, ${scaleY === -1 ? -100 : 0})`
                })]);
                const cells = [create(1), create(-1), create(1)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(-1)
                    }, {
                        svg: createStar(color, {
                            fill: true
                        })
                    }, {
                        svg: createPolygon(4, color, {
                            stroke: true
                        })
                    }]
                };
            }
        }, {
            name: "Shrink",
            generateRow: (color) => {
                const create = (scale) => {
                    const star = createStar(color, {
                        fill: true
                    }).firstChild;
                    const g = createGroup([star], {
                        transform: `translate(50, 50) scale(${scale}) translate(-50, -50)`
                    });
                    return createSVG([g]);
                };
                const cells = [create(1.0), create(0.8), create(0.6)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(0.4)
                    }, {
                        svg: create(1.2)
                    }, {
                        svg: create(1.0)
                    }]
                };
            }
        }, {
            name: "Positional Shift: Diagonal",
            generateRow: (color) => {
                const create = (cx, cy) => createSVG([createSVGElement('circle', {
                    r: 10,
                    fill: color,
                    cx,
                    cy
                })]);
                const cells = [create(25, 25), create(50, 50), create(75, 75)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(25, 75)
                    }, {
                        svg: create(75, 25)
                    }, {
                        svg: create(50, 25)
                    }]
                };
            }
        }, {
            name: "Shape Division",
            generateRow: (color) => {
                const create = (step) => {
                    switch (step) {
                        case 1:
                            return createSVG([createSVGElement('rect', {
                                x: 10,
                                y: 40,
                                width: 80,
                                height: 20,
                                fill: color
                            })]);
                        case 2:
                            return createSVG([createSVGElement('rect', {
                                x: 10,
                                y: 25,
                                width: 80,
                                height: 20,
                                fill: color
                            }), createSVGElement('rect', {
                                x: 10,
                                y: 55,
                                width: 80,
                                height: 20,
                                fill: color
                            })]);
                        case 3:
                            return createSVG([createSVGElement('rect', {
                                x: 10,
                                y: 10,
                                width: 80,
                                height: 20,
                                fill: color
                            }), createSVGElement('rect', {
                                x: 10,
                                y: 70,
                                width: 80,
                                height: 20,
                                fill: color
                            })]);
                        default:
                            return createSVG([]);
                    }
                };
                const cells = [create(1), create(2), create(3)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(1)
                    }, {
                        svg: create(2)
                    }, {
                        svg: createPolygon(4, color, {
                            fill: true
                        })
                    }]
                };
            }
        }, {
            name: "Opacity Decrease",
            generateRow: (color) => {
                const create = (opacity) => createPolygon(6, color, {
                    fill: true,
                    opacity: opacity
                });
                const cells = [create(1.0), create(0.65), create(0.3)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(1.0)
                    }, {
                        svg: create(0.65)
                    }, {
                        svg: create(0.1)
                    }]
                };
            }
        }, {
            name: "Line Count Progression",
            generateRow: (color) => {
                const create = (count) => {
                    const lines = [];
                    for (let i = 0; i < count; i++) {
                        const y = 25 + i * 25;
                        lines.push(createSVGElement('line', {
                            x1: 15,
                            y1: y,
                            x2: 85,
                            y2: y,
                            stroke: color,
                            'stroke-width': 8
                        }));
                    }
                    return createSVG(lines);
                };
                const cells = [create(1), create(2), create(3)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(4)
                    }, {
                        svg: create(1)
                    }, {
                        svg: create(2)
                    }]
                };
            }
        }, {
            name: "Logical Subtraction (A-B)",
            generateRow: (color) => {
                const clipId = `clip-sub-${Math.random()}`;
                const defs = createSVGElement('defs', {});
                defs.innerHTML = `<clipPath id="${clipId}"><path d="M0,0 H100 V100 H0 Z M25,25 H75 V75 H25 Z" clip-rule="evenodd"></path></clipPath>`;
                const shapeA = createSVGElement('circle', {
                    cx: 50,
                    cy: 50,
                    r: 45,
                    fill: color
                });
                const shapeB = createSVGElement('rect', {
                    x: 25,
                    y: 25,
                    width: 50,
                    height: 50,
                    fill: color
                });
                const result = shapeA.cloneNode(true);
                result.setAttribute('clip-path', `url(#${clipId})`);

                const cells = [createSVG([shapeA.cloneNode(true)]), createSVG([shapeB.cloneNode(true)]), createSVG([result], defs)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: createSVG([shapeB.cloneNode(true)])
                    }, {
                        svg: createSVG([shapeA.cloneNode(true), shapeB.cloneNode(true)])
                    }, {
                        svg: createSVG([shapeA.cloneNode(true)])
                    }]
                };
            }
        }, {
            name: "Shape Alternation (ABA)",
            generateRow: (color) => {
                const shapeA = createPolygon(3, color, {
                    fill: true
                });
                const shapeB = createPolygon(5, color, {
                    fill: true
                });
                const cells = [shapeA, shapeB, shapeA.cloneNode(true)];
                return {
                    cells,
                    answer: {
                        svg: shapeA
                    },
                    distractors: [{
                        svg: shapeB
                    }, {
                        svg: createPolygon(4, color, {
                            fill: true
                        })
                    }, {
                        svg: createStar(color, {
                            fill: true
                        })
                    }]
                };
            }
        }, {
            name: "Grid Fill",
            generateRow: (color) => {
                const create = (count) => {
                    const gridLines = [
                        createSVGElement('path', {
                            d: "M50 10 V 90 M10 50 H 90",
                            stroke: '#ccc',
                            'stroke-width': 2
                        })
                    ];
                    const quads = [
                        createSVGElement('rect', {
                            x: 10,
                            y: 10,
                            width: 40,
                            height: 40,
                            fill: color
                        }),
                        createSVGElement('rect', {
                            x: 50,
                            y: 10,
                            width: 40,
                            height: 40,
                            fill: color
                        }),
                        createSVGElement('rect', {
                            x: 10,
                            y: 50,
                            width: 40,
                            height: 40,
                            fill: color
                        }),
                        createSVGElement('rect', {
                            x: 50,
                            y: 50,
                            width: 40,
                            height: 40,
                            fill: color
                        })
                    ];
                    return createSVG([...gridLines, ...quads.slice(0, count)]);
                };
                const cells = [create(1), create(2), create(3)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(4)
                    }, {
                        svg: create(2)
                    }, {
                        svg: create(1)
                    }]
                };
            }
        }, {
            name: "Rotation 45 degrees",
            generateRow: (color) => {
                const plus = createSVGElement('path', {
                    d: "M40 10 H 60 V 40 H 90 V 60 H 60 V 90 H 40 V 60 H 10 V 40 H 40 Z"
                });
                const create = (angle) => createSVG([createGroup([applyStyle(plus.cloneNode(true), color, {
                    fill: true
                })], {
                    transform: `rotate(${angle} 50 50)`
                })]);

                const cells = [create(0), create(45), create(90)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(45)
                    }, {
                        svg: createPolygon(3, color, {
                            fill: true
                        })
                    }, {
                        svg: createStar(color, {
                            stroke: true,
                            strokeWidth: 6
                        })
                    }]
                };
            }
        }, {
            name: "Reflection Across Center",
            generateRow: (color) => {
                const tri = createSVGElement('path', {
                    d: "M20 20 L 40 20 L 20 40 Z",
                    fill: color
                });
                const create = (count) => {
                    // DÜZELTME: Her kullanımda ana şeklin kopyası (clone) alınarak elementin çalınması engellendi.
                    const shapes = [tri.cloneNode(true)];
                    if (count > 1) {
                        const reflected_tri = createGroup([tri.cloneNode(true)], {
                            transform: 'translate(100, 100) rotate(180)'
                        });
                        shapes.push(reflected_tri);
                    }
                    return createSVG(shapes);
                };
                const cells = [create(1), create(1), create(2)];
                return {
                    cells,
                    answer: {
                        svg: create(2)
                    },
                    distractors: [{
                        svg: create(1)
                    }, {
                        svg: createPolygon(4, color, {
                            fill: true
                        })
                    }, {
                        svg: createStar(color, {
                            fill: true
                        })
                    }]
                };
            }
        }, {
            name: "Inner Shape Rotation",
            generateRow: (color) => {
                const outer = createPolygon(8, color, {
                    stroke: true
                }).firstChild;
                const inner = createSVGElement('path', {
                    d: "M50 30 L60 50 L40 50 Z",
                    fill: color
                });
                const create = (angle) => {
                    const rotated_inner = createGroup([inner.cloneNode(true)], {
                        transform: `rotate(${angle} 50 50)`
                    });
                    return createSVG([outer.cloneNode(true), rotated_inner]);
                };
                const cells = [create(0), create(90), create(180)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(270)
                    }, {
                        svg: create(0)
                    }, {
                        svg: create(45)
                    }]
                };
            }
        }, {
            name: "Arithmetic Progression of Shapes",
            generateRow: (color) => {
                const create = (count) => {
                    const shapes = [];
                    for (let i = 0; i < count; i++) {
                        const y = 20 + i * 30;
                        shapes.push(createSVGElement('rect', {
                            x: 35,
                            y: y,
                            width: 30,
                            height: 15,
                            fill: color
                        }));
                    }
                    return createSVG(shapes);
                };
                const cells = [create(1), create(2), create(3)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: create(4)
                    }, {
                        svg: create(1)
                    }, {
                        svg: create(2)
                    }]
                };
            }
        }, {
            name: "Positional Bounce",
            generateRow: (color) => {
                const dot = (cx, cy) => createSVG([createSVGElement('circle', {
                    r: 10,
                    fill: color,
                    cx,
                    cy
                })]);
                const cells = [dot(20, 20), dot(80, 20), dot(80, 80)];
                return {
                    cells,
                    answer: {
                        svg: cells[2]
                    },
                    distractors: [{
                        svg: dot(20, 80)
                    }, {
                        svg: dot(20, 20)
                    }, {
                        svg: dot(50, 50)
                    }]
                };
            }
        },];


        function generatePuzzle() {
            gridContainer.innerHTML = '';
            optionsContainer.innerHTML = '';
            feedbackEl.innerHTML = '';
            feedbackEl.className = '';
            usedColors = [];

            currentRule = RULES[Math.floor(Math.random() * RULES.length)];
            let lastRowData;

            for (let i = 0; i < 3; i++) {
                let randomColor = COLORS[Math.floor(Math.random() * COLORS.length)];
                let attempts = 0;
                while (usedColors.includes(randomColor) && attempts < COLORS.length) {
                    randomColor = COLORS[Math.floor(Math.random() * COLORS.length)];
                    attempts++;
                }
                usedColors.push(randomColor);

                const rowData = currentRule.generateRow(randomColor);
                if (i === 2) lastRowData = rowData;

                rowData.cells.forEach((cellSVG, j) => {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (i === 2 && j === 2) {
                        cell.textContent = '?';
                        correctAnswerData = rowData.answer;
                    } else {
                        if (cellSVG && cellSVG.nodeName === 'svg' && cellSVG.innerHTML.trim() !== '') {
                            cell.appendChild(cellSVG);
                        } else {
                            console.error("Hücre için geçersiz veya boş SVG oluşturuldu:", currentRule.name);
                            cell.innerHTML = '<span style="color: red; font-size: 20px;">HATA</span>'; // Show explicit error
                        }
                    }
                    gridContainer.appendChild(cell);
                });
            }
            generateOptions(lastRowData);
        }

        function generateOptions(rowData) {
            if (!rowData || !correctAnswerData || !correctAnswerData.svg) {
                console.error("Seçenekler oluşturulamadı: Hatalı satır verisi.");
                return;
            }

            const finalOptions = [];
            const seenHTMLs = new Set();

            finalOptions.push({
                svg: correctAnswerData.svg,
                correct: true
            });
            seenHTMLs.add(correctAnswerData.svg.outerHTML);

            const distractorPool = [...rowData.distractors];

            let attempts = 0;
            while (finalOptions.length < 4 && attempts < 50) {
                let candidate = distractorPool.length > 0 ?
                    distractorPool.shift() :
                    generateFallbackDistractor(usedColors[2]);

                if (candidate && candidate.svg) {
                    const candidateHTML = candidate.svg.outerHTML;
                    if (!seenHTMLs.has(candidateHTML)) {
                        seenHTMLs.add(candidateHTML);
                        finalOptions.push({
                            svg: candidate.svg,
                            correct: false
                        });
                    }
                }
                attempts++;
            }

            if (finalOptions.length < 4) {
                console.error("Kural için 4 benzersiz seçenek üretilemedi:", currentRule.name);
            }

            finalOptions.sort(() => Math.random() - 0.5);

            finalOptions.forEach(opt => {
                const optionEl = document.createElement('div');
                optionEl.className = 'option';
                optionEl.appendChild(opt.svg.cloneNode(true));
                if (opt.correct) {
                    optionEl.dataset.correct = 'true';
                }
                optionEl.addEventListener('click', handleOptionClick);
                optionsContainer.appendChild(optionEl);
            });
        }


        function handleOptionClick(event) {
            if (feedbackEl.textContent) return;

            const clickedOption = event.currentTarget;
            if (clickedOption.dataset.correct === 'true') {
                feedbackEl.textContent = 'Tebrikler, Doğru!';
                feedbackEl.className = 'correct';
                const questionMarkCell = gridContainer.children[8];
                questionMarkCell.textContent = '';
                questionMarkCell.appendChild(correctAnswerData.svg.cloneNode(true));
            } else {
                feedbackEl.textContent = 'Yanlış cevap, kuralı tekrar düşünün.';
                feedbackEl.className = 'incorrect';
            }
        }

        newGameBtn.addEventListener('click', generatePuzzle);
        document.addEventListener('DOMContentLoaded', generatePuzzle);
    </script>
</body>

</html>