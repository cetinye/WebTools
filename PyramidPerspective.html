<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pyramid Perspective</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #f0f0f0;
            font-family: sans-serif;
            margin: 0;
            padding: 2rem;
        }

        canvas {
            border: 1px solid #ccc;
            margin-bottom: 1rem;
            background: white;
        }

        .options {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .option-canvas {
            border: 2px solid transparent;
            cursor: pointer;
        }

        .option-canvas.selected {
            border-color: #007bff;
        }
    </style>
</head>

<body>
    <h2>Piramit Perspektif Oyunu</h2>
    <canvas id="mainView" width="300" height="300"></canvas>
    <div class="options">
        <canvas class="option-canvas" width="100" height="100"></canvas>
        <canvas class="option-canvas" width="100" height="100"></canvas>
        <canvas class="option-canvas" width="100" height="100"></canvas>
        <canvas class="option-canvas" width="100" height="100"></canvas>
    </div>

    <script>
        const mainCanvas = document.getElementById('mainView');
        const mainCtx = mainCanvas.getContext('2d');
        const optionCanvases = document.querySelectorAll('.option-canvas');

        const colors = ['#FF5733', '#F1C40F', '#9B59B6', '#1ABC9C', '#E74C3C', '#3498DB'];
        let correctIndex = 1;
        let selectedOption = null;
        let currentColorOrder = [];
        let currentSides = 6;

        function getRandomColorOrder(length) {
            const arr = Array.from({ length }, (_, i) => i);
            return arr.sort(() => 0.5 - Math.random());
        }

        function drawWireframePyramid(ctx, sides, colorOrder) {
            const cx = ctx.canvas.width / 2;
            const cy = ctx.canvas.height * 0.75;
            const r = ctx.canvas.width / 3.2;
            const angle = (Math.PI * 2) / sides;

            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Create base points - simple isometric-like view
            const points = [];
            for (let i = 0; i < sides; i++) {
                const baseAngle = angle * i + Math.PI / 8; // Rotate to the right
                const x = cx + r * Math.cos(baseAngle);
                const y = cy + r * Math.sin(baseAngle) * 0.5; // Moderate perspective
                points.push({ x, y });
            }

            // Simple apex position
            const apex = { x: cx, y: cy - r * 1.4 };

            // Draw all base edges with consistent color mapping
            for (let i = 0; i < sides; i++) {
                const a = points[i];
                const b = points[(i + 1) % sides];
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = colors[colorOrder[i]];
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw all edges from apex to base with consistent color mapping
            for (let i = 0; i < sides; i++) {
                ctx.beginPath();
                ctx.moveTo(apex.x, apex.y);
                ctx.lineTo(points[i].x, points[i].y);
                ctx.strokeStyle = colors[colorOrder[i]];
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawTopDownWithInnerLines(ctx, sides, colorOrder) {
            const cx = ctx.canvas.width / 2;
            const cy = ctx.canvas.height / 2;
            const r = ctx.canvas.width / 2 - 10;
            const angle = (Math.PI * 2) / sides;

            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const points = [];

            for (let i = 0; i < sides; i++) {
                // Match the same rotation as the 3D view
                const x = cx + r * Math.cos(angle * i + Math.PI / 8);
                const y = cy + r * Math.sin(angle * i + Math.PI / 8);
                points.push({ x, y });
            }

            // Draw outer edges with consistent color mapping
            for (let i = 0; i < sides; i++) {
                const a = points[i];
                const b = points[(i + 1) % sides];
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = colors[colorOrder[i]];
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw inner lines from center to vertices with consistent color mapping
            for (let i = 0; i < sides; i++) {
                ctx.beginPath();
                ctx.moveTo(points[i].x, points[i].y);
                ctx.lineTo(cx, cy);
                ctx.strokeStyle = colors[colorOrder[i]];
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }

        function setupGame() {
            // Now includes triangle (3), square (4), pentagon (5), and hexagon (6) pyramids
            const possibleSides = [3, 4, 5, 6];
            currentSides = possibleSides[Math.floor(Math.random() * possibleSides.length)];
            currentColorOrder = getRandomColorOrder(currentSides);
            correctIndex = Math.floor(Math.random() * 4);

            drawWireframePyramid(mainCtx, currentSides, currentColorOrder);

            // Create unique variations for each option
            const usedVariations = new Set();
            const variations = [];

            // Add the correct answer
            variations[correctIndex] = [...currentColorOrder];
            usedVariations.add(JSON.stringify(currentColorOrder));

            // Generate unique wrong answers
            optionCanvases.forEach((canvas, idx) => {
                const ctx = canvas.getContext('2d');
                let variation;

                if (idx === correctIndex) {
                    variation = [...currentColorOrder];
                } else {
                    // Keep generating until we get a unique variation
                    do {
                        variation = getRandomColorOrder(currentSides);
                    } while (usedVariations.has(JSON.stringify(variation)));

                    usedVariations.add(JSON.stringify(variation));
                    variations[idx] = variation;
                }

                drawTopDownWithInnerLines(ctx, currentSides, variation);

                canvas.onclick = () => {
                    optionCanvases.forEach(c => c.classList.remove('selected'));
                    canvas.classList.add('selected');
                    selectedOption = idx;

                    if (selectedOption === correctIndex) {
                        alert('Tebrikler, doğru tahmin!');
                    } else {
                        alert('Yanlış tahmin, tekrar deneyin.');
                    }
                    setupGame();
                };
            });
        }

        setupGame();
    </script>
</body>

</html>