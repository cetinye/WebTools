<!DOCTYPE html>
<html lang="tr">

<head>
  <meta charset="UTF-8">
  <title>Cube Gap Perspective Game</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #ffffff;
    }

    /* --- YENİ: Canvas ve SVG'yi sarmalayan kapsayıcı --- */
    #canvas-wrapper {
      position: relative;
      width: 600px;
      height: 400px;
      margin: 20px auto;
    }

    canvas {
      background: #fff;
      display: block;
      /* margin kaldırıldı, wrapper'a taşındı */
    }

    /* --- YENİ: SVG gösterge stili --- */
    .view-indicator-svg {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      width: 70px;
      /* SVG boyutu */
      pointer-events: none;
      /* Tıklamaları engellememesi için */
    }

    .options {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    .option {
      display: grid;
      grid-template-columns: repeat(4, 20px);
      gap: 2px;
      cursor: pointer;
      padding: 5px;
      /* Kenarlık eklendi */
    }

    .option:hover {
      border-color: #4caf50;
    }

    .cell {
      width: 20px;
      height: 20px;
      background-color: #ffffff;
    }

    .filled {
      background-color: #00bcd4;
    }

    #result {
      margin-top: 20px;
      font-size: 20px;
      font-weight: bold;
      min-height: 24px;
    }
  </style>
</head>

<body>
  <span id="correctIndex" style="display:none;"></span>

  <div id="canvas-wrapper">
    <canvas id="canvas" width="600" height="400"></canvas>
    <div class="view-indicator-svg">
      <svg viewBox="0 0 100 85" xmlns="http://www.w3.org/2000/svg">
        <path d="M50 15C25 15 5 35 5 35S25 55 50 55s45-20 45-20S75 15 50 15z" fill="none" stroke="#333"
          stroke-width="5" />
        <circle cx="50" cy="35" r="15" fill="#333" />
        <path d="M35 55 L35 80 L30 75 M35 80 L40 75" fill="none" stroke="currentColor" stroke-width="4"
          stroke-linecap="round" stroke-linejoin="round" />
        <path d="M50 55 L50 80 L45 75 M50 80 L55 75" fill="none" stroke="currentColor" stroke-width="4"
          stroke-linecap="round" stroke-linejoin="round" />
        <path d="M65 55 L65 80 L60 75 M65 80 L70 75" fill="none" stroke="currentColor" stroke-width="4"
          stroke-linecap="round" stroke-linejoin="round" />
      </svg>
    </div>
  </div>
  <div class="options" id="options"></div>
  <p id="result"></p>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cubeSize = 30;
    const offsetX = canvas.width / 2;
    const offsetY = 150;
    const gridSize = 4;
    const layers = 3;

    function drawIsoCube(x, y, z, color = '#00bcd4') {
      const isoX = (x - y) * cubeSize + offsetX;
      const isoY = (x + y) * cubeSize / 2 - z * cubeSize + offsetY;
      ctx.beginPath();
      ctx.moveTo(isoX, isoY);
      ctx.lineTo(isoX + cubeSize, isoY + cubeSize / 2);
      ctx.lineTo(isoX, isoY + cubeSize);
      ctx.lineTo(isoX - cubeSize, isoY + cubeSize / 2);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(isoX - cubeSize, isoY + cubeSize / 2);
      ctx.lineTo(isoX, isoY + cubeSize);
      ctx.lineTo(isoX, isoY + cubeSize * 2);
      ctx.lineTo(isoX - cubeSize, isoY + cubeSize * 1.5);
      ctx.closePath();
      ctx.fillStyle = darkenColor(color, 0.2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(isoX, isoY + cubeSize);
      ctx.lineTo(isoX + cubeSize, isoY + cubeSize / 2);
      ctx.lineTo(isoX + cubeSize, isoY + cubeSize * 1.5);
      ctx.lineTo(isoX, isoY + cubeSize * 2);
      ctx.closePath();
      ctx.fillStyle = darkenColor(color, 0.4);
      ctx.fill();
    }

    function darkenColor(hex, percent) {
      const num = parseInt(hex.replace("#", ""), 16);
      const amt = Math.round(2.55 * percent * 100);
      const R = (num >> 16) - amt;
      const G = ((num >> 8) & 0x00FF) - amt;
      const B = (num & 0x0000FF) - amt;
      return `rgb(${Math.max(R, 0)},${Math.max(G, 0)},${Math.max(B, 0)})`;
    }

    function generateConnectedStructure() {
      const structure = Array.from({ length: layers }, () =>
        Array.from({ length: gridSize }, () => Array(gridSize).fill(0))
      );
      const queue = [];
      const startX = Math.floor(Math.random() * gridSize);
      const startY = Math.floor(Math.random() * gridSize);
      const startZ = Math.floor(Math.random() * layers);
      structure[startZ][startY][startX] = 1;
      queue.push([startX, startY, startZ]);
      let placed = 1;
      while (placed < 6 && queue.length > 0) {
        const [x, y, z] = queue.shift();
        const directions = [
          [1, 0, 0], [-1, 0, 0], [0, 1, 0],
          [0, -1, 0], [0, 0, 1], [0, 0, -1]
        ];
        for (const [dx, dy, dz] of directions.sort(() => Math.random() - 0.5)) {
          const nx = x + dx;
          const ny = y + dy;
          const nz = z + dz;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && nz >= 0 && nz < layers) {
            if (!structure[nz][ny][nx]) {
              structure[nz][ny][nx] = 1;
              queue.push([nx, ny, nz]);
              placed++;
              break;
            }
          }
        }
      }
      return structure;
    }

    function getTopView(structure) {
      const top = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
      for (let z = layers - 1; z >= 0; z--) {
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            if (structure[z][y][x] && top[y][x] === 0) top[y][x] = 1;
          }
        }
      }
      return top;
    }

    function drawStructure(structure) {
      for (let z = 0; z < layers; z++) {
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            if (structure[z][y][x]) drawIsoCube(x, y, z);
          }
        }
      }
    }

    // --- KALDIRILDI: Bu fonksiyon artık kullanılmıyor. ---
    /*
    function drawTopViewIndicator() { ... }
    */

    function cloneMatrix(matrix) {
      return matrix.map(row => row.slice());
    }

    function generateFakeOption(correct) {
      const fake = cloneMatrix(correct);
      const changes = Math.random() < 0.7 ? 1 : 2;
      for (let i = 0; i < changes; i++) {
        const y = Math.floor(Math.random() * gridSize);
        const x = Math.floor(Math.random() * gridSize);
        fake[y][x] = 1 - fake[y][x];
      }
      return fake;
    }

    function drawOptions(correct) {
      const options = [{ data: correct, correct: true }];
      while (options.length < 4) {
        const fake = generateFakeOption(correct);
        if (!options.some(opt => JSON.stringify(opt.data) === JSON.stringify(fake))) {
          options.push({ data: fake, correct: false });
        }
      }
      options.sort(() => Math.random() - 0.5);

      const correctIndex = options.findIndex(opt => opt.correct === true);
      document.getElementById('correctIndex').textContent = correctIndex;

      const container = document.getElementById('options');
      container.innerHTML = '';
      options.forEach(option => {
        const div = document.createElement('div');
        div.className = 'option';
        option.data.forEach(row => {
          row.forEach(cell => {
            const el = document.createElement('div');
            el.className = 'cell';
            if (cell) el.classList.add('filled');
            div.appendChild(el);
          });
        });
        div.onclick = () => {
          document.getElementById('result').textContent = option.correct ? '✅ Doğru cevap!' : '❌ Yanlış cevap.';
          container.style.pointerEvents = 'none';
          document.querySelectorAll('.option').forEach((optDiv, index) => {
            if (options[index].correct) {
              optDiv.style.borderColor = '#4caf50';
              optDiv.style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
            } else if (optDiv === div && !option.correct) {
              optDiv.style.borderColor = '#f44336';
              optDiv.style.backgroundColor = 'rgba(244, 67, 54, 0.2)';
            }
          });
        };
        container.appendChild(div);
      });
    }

    const structure = generateConnectedStructure();
    drawStructure(structure);
    // --- KALDIRILDI: drawTopViewIndicator() çağrısı kaldırıldı. ---
    const topView = getTopView(structure);
    drawOptions(topView);
  </script>
</body>

</html>